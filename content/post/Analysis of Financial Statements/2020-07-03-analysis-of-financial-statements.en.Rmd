---
title: "Analysis of Financial Statements"
author: "Colin James"
date: '2020-07-03'
output: pdf_document
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
lastmod: '2020-07-03T15:00:32-04:00'
categories: []
projects: []
slug: analysis-of-financial-statements
subtitle: ''
summary: ''
tags: []
authors: []
---

```{r Installing Necessary Packages, message=FALSE, warning=FALSE}
#install.packages("XBRL")
#install.packages("finreportr")

library("ggplot2")
library("quantmod")
library("dplyr")
library("finreportr")
library("XBRL")

```
## Analysis of Financial Statments

In this blog we are going to connect to the EDGAR database and analyze the most recent 10Ks of Apple

##Liquidity Ratios

#XBRL

Quick note about the finreportr function.  XBRl stands for eXtensive Business Reporting Language is a global framework to exchange business information.  The reason this R package makes this information so readily accessible is because the package is able to convert XBRL into a more usable format.  

```{r Current Ratio}
#install the financial report (finreportr) R package. 
  CompanyInfo("AAPL")
  
  AnnualReports("AAPL")
  
  appleincomestatement <- GetIncome("AAPL", 2010)
  
#Liquidity Ratios, Current and Quick.  Current Ratio = Current Assets/Current Liabilities.
  
#Current Ratio
applebalancesheet10 <- GetBalanceSheet("AAPL", 2010)
Year_2010 <- as.numeric(applebalancesheet10[31,3])/as.numeric(applebalancesheet10[49,3])

applebalancesheet11 <- GetBalanceSheet("AAPL", 2011)
Year_2011 <- as.numeric(applebalancesheet11[31,3])/as.numeric(applebalancesheet11[49,3])

applebalancesheet12 <- GetBalanceSheet("AAPL", 2012)
Year_2012 <- as.numeric(applebalancesheet12[28,3])/as.numeric(applebalancesheet12[48,3])

applebalancesheet13 <- GetBalanceSheet("AAPL", 2013)
Year_2013 <- as.numeric(applebalancesheet13[30,3])/as.numeric(applebalancesheet13[50,3])

applebalancesheet14 <- GetBalanceSheet("AAPL", 2014)
Year_2014 <- as.numeric(applebalancesheet14[30,3])/as.numeric(applebalancesheet14[52,3])

applebalancesheet15 <- GetBalanceSheet("AAPL", 2015)
Year_2015 <- as.numeric(applebalancesheet15[30,3])/as.numeric(applebalancesheet15[54,3])

applebalancesheet16 <- GetBalanceSheet("AAPL", 2016)
Year_2016 <- as.numeric(applebalancesheet16[16,3])/as.numeric(applebalancesheet16[42,3])

applebalancesheet17 <- GetBalanceSheet("AAPL", 2017)
Year_2017 <- as.numeric(applebalancesheet17[16,3])/as.numeric(applebalancesheet17[40,3])

#Create table for 
C_Ratios <- as.data.frame(rbind(Year_2010,Year_2011,Year_2012,Year_2013, Year_2014,Year_2015,Year_2016, Year_2017))

C_Years <- rbind("2010", "2011", "2012", "2013", "2014", "2015", "2016", "2017")

CA_By_Year <- as.data.frame(cbind(C_Years, C_Ratios))

#Created a simple line graph to show the Current Ratio Over time
ggplot(data = CA_By_Year, aes(x = C_Years, y = V1, group=1)) + 
  geom_line(color="red") +
  geom_hline(aes(yintercept = mean(V1)), color="blue") +
  labs(title="Current Ratios for Apple", x="Year", y="Current Ratio")

```


```{r Quick Ratio}
#install the edgar R package
  appleincomestatement <- GetIncome("AAPL", 2010)
  
#Liquidity Ratios, Current and Quick.
#Quick Ratio = Current Assets - Inventories/Current Liabilities
  
#Quick Ratio
Year_2010 <- (as.numeric(applebalancesheet10[31,3])-as.numeric(applebalancesheet10[23,3]))/as.numeric(applebalancesheet10[49,3])

Year_2011 <- (as.numeric(applebalancesheet11[31,3])-as.numeric(applebalancesheet11[23,3]))/as.numeric(applebalancesheet11[49,3])

Year_2012 <- (as.numeric(applebalancesheet12[30,3])-as.numeric(applebalancesheet12[22,3]))/as.numeric(applebalancesheet12[48,3])

Year_2013 <- (as.numeric(applebalancesheet13[30,3])-as.numeric(applebalancesheet13[22,3]))/as.numeric(applebalancesheet13[50,3])

Year_2014 <- (as.numeric(applebalancesheet14[30,3])-as.numeric(applebalancesheet14[22,3]))/as.numeric(applebalancesheet14[52,3])

Year_2015 <- (as.numeric(applebalancesheet15[30,3])-as.numeric(applebalancesheet15[22,3]))/as.numeric(applebalancesheet15[54,3])

Year_2016 <- (as.numeric(applebalancesheet16[16,3])-as.numeric(applebalancesheet16[10,3]))/as.numeric(applebalancesheet16[42,3])

Year_2017 <- (as.numeric(applebalancesheet17[16,3])-as.numeric(applebalancesheet17[10,3]))/as.numeric(applebalancesheet17[40,3])

#Create table for 
Q_Ratios <- as.data.frame(rbind(Year_2010,Year_2011,Year_2012,Year_2013, Year_2014,Year_2015,Year_2016, Year_2017))

Q_Years <- rbind("2010", "2011", "2012", "2013", "2014", "2015", "2016", "2017")

QR_By_Year <- as.data.frame(cbind(Q_Years, Q_Ratios))

#Created a simple line graph to show the Current Ratio Over time
ggplot(data = QR_By_Year, aes(x = Q_Years, y = V1, group=1)) + 
  geom_line(color="red") +
  geom_hline(aes(yintercept = mean(V1)), color="blue") +
  labs(title="Current Ratios for Apple", x="Year", y="Quick Ratio")

```

##Asset Management Ratios

```{r Inventory Turnover Ratios}
#install the edgar R package
  appleincomestatement <- GetIncome("AAPL", 2010)

print(AnnualReports("AAPL"))  
  
head(GetIncome("GOOG", 2016))

#Liquidity Ratios, Current and Quick.
#Quick Ratio = Current Assets - Inventories/Current Liabilities
  
#Quick Ratio
appleincomestatement10 <- GetIncome("GOOG", 2010)

Year_2010 <- (as.numeric(appleincomestatement10[31,3])/as.numeric(applebalancesheet10[23,3]))

Year_2011 <- (as.numeric(applebalancesheet11[31,3])-as.numeric(applebalancesheet11[23,3]))/as.numeric(applebalancesheet11[49,3])

Year_2012 <- (as.numeric(applebalancesheet12[30,3])-as.numeric(applebalancesheet12[22,3]))/as.numeric(applebalancesheet12[48,3])

Year_2013 <- (as.numeric(applebalancesheet13[30,3])-as.numeric(applebalancesheet13[22,3]))/as.numeric(applebalancesheet13[50,3])

Year_2014 <- (as.numeric(applebalancesheet14[30,3])-as.numeric(applebalancesheet14[22,3]))/as.numeric(applebalancesheet14[52,3])

Year_2015 <- (as.numeric(applebalancesheet15[30,3])-as.numeric(applebalancesheet15[22,3]))/as.numeric(applebalancesheet15[54,3])

Year_2016 <- (as.numeric(applebalancesheet16[16,3])-as.numeric(applebalancesheet16[10,3]))/as.numeric(applebalancesheet16[42,3])

Year_2017 <- (as.numeric(applebalancesheet17[16,3])-as.numeric(applebalancesheet17[10,3]))/as.numeric(applebalancesheet17[40,3])

#Create table for 
Q_Ratios <- as.data.frame(rbind(Year_2010,Year_2011,Year_2012,Year_2013, Year_2014,Year_2015,Year_2016, Year_2017))

Q_Years <- rbind("2010", "2011", "2012", "2013", "2014", "2015", "2016", "2017")

QR_By_Year <- as.data.frame(cbind(Q_Years, Q_Ratios))

#Created a simple line graph to show the Current Ratio Over time
ggplot(data = QR_By_Year, aes(x = Q_Years, y = V1, group=1)) + 
  geom_line(color="red") +
  geom_hline(aes(yintercept = mean(V1)), color="blue") +
  labs(title="Current Ratios for Apple", x="Year", y="Quick Ratio")


#New Path
install.packages("xml")

install.packages('xml',repos='http://cran.us.r-project.org')


Sys.unsetenv("GITHUB_PAT")
remotes::install_github(
  repo = "bergant/xbrlus", force = TRUE) 

library(xbrlus)
library("xml2")

companies <- xbrlCIKLookup(c("aapl","goog","fb"))

elements <- xbrlBaseElement(c("AssetsCurrent","AssetsNoncurrent","Assets","LiabilitiesCurrent",
  "LiabilitiesNoncurrent","Liabilities","StockholdersEquity","MinorityInterest",
  "StockholdersEquityIncludingPortionAttributableToNoncontrollingInterest","LiabilitiesAndStockholdersEquity"))


#Check to confirm API key is working properly

xbrlus_url <- "https://csuite.xbrl.us/php/dispatch.php?"


xbrlus_api_key <- function() {
  key <- Sys.getenv("XBRLUS_API_KEY")
  if(key == "") {
    stop("XBRLUS_API_KEY environment variable is empty. Type ?xbrlus for help.")
  }
  key
}

xbrlus_get <- function(task, params, add_api_key = TRUE) {
  query <- c(list(Task = task), params)

  if(add_api_key) {
    query[["API_Key"]] = xbrlus_api_key()
  }
  res <- httr::GET(xbrlus_url, query = query)
  xbrlus_validate(res)
  xbrlus_parse(res)
}

xbrlus_validate <- function(res) {

  if(!inherits(res, "response")) {
    stop("Not a HTTP response object")
  }
  if(res$status_code >= 400) {
    err_message <- httr::content(res, as = "text", encoding = "UTF-8")
    if( XML::isXMLString(err_message)) {
      doc <- XML::xmlParse(err_message, options = XML::NOCDATA)
      lerror <- XML::xmlToList(doc)
      err_message <- paste(lerror, collapse = "\n")
    }
    stop("HTTP error: ", res$status_code, "\n", err_message, call. = FALSE)
  }
  if(substring(res$headers$`content-type`, 1, 8) != "text/xml") {
    stop("Returned message is not an xml", call. = FALSE)
  }

}

xbrlus_parse <- function(res) {
  res_txt <- httr::content(res, as = "text", encoding = "UTF-8")
  doc <- XML::xmlParse(res_txt, asText = TRUE, options = XML::NOCDATA)
  XML::xmlToList(doc)
}

xbrlus_to_data_frame <- function(ret, element_name = "fact") {
  if(!any(names(ret) == element_name)) return(data.frame())
  ret <- do.call(
    rbind,
    c(lapply(ret[names(ret) == element_name], function(x) {
      x[sapply(x,is.null)] <- NA
      as.data.frame(x, stringsAsFactors = FALSE)
    }),
    make.row.names = FALSE)
  )
}


# xbrlBaseElement Function
xbrlBaseElement <- function(Element, Namespace = NULL, as_data_frame = TRUE) {
  if(length(Element) > 1) {

    ret_list <-
      lapply(
        Element, xbrlBaseElement,
        Namespace = Namespace, as_data_frame = as_data_frame
      )
    # using Reduce/merge instead of do.call/rbind because some columns
    #  in xbrlus database could be missing (see #3 issue)
    ret_df <- Reduce(function(x, y) {merge(x, y, all = TRUE)}, ret_list)
    return(ret_df)

  }
  ret <- xbrlus_get("xbrlBaseElement", list(
    Element=Element,
    Namespace = Namespace
  ))
  if(as_data_frame) {
    ret <- xbrlus_to_data_frame(ret, "baseElement")
  }
  ret
}


#xbrlValues function in R
xbrlValues <- function(
  AccessionID = NULL, Accession = NULL, CIK = NULL, Restated = NULL,
  Element = NULL, Axis = NULL, Member = NULL, Dimension = NULL, DimReqd = NULL,
  ExtensionElement = NULL, ExtensionAxis = NULL, ExtensionMember = NULL,
  Period = NULL, StartYear = NULL, NoYears = NULL, Year = NULL, Ultimus = NULL,
  Small = NULL, as_data_frame = TRUE
)
{
  if(length(CIK) > 1) {
    CIK <- paste(CIK, collapse = ", ")
  }
  if(length(Element) > 1) {
    Element <- paste(Element, collapse = ", ")
  }

  ret <-
    xbrlus_get("xbrlValues", list(
      AccessionID = AccessionID,
      Accession = Accession,
      CIK = CIK,
      Restated = Restated,

      Element = Element,
      Axis = Axis,
      Member = Member,
      Dimension = Dimension,
      DimReqd = DimReqd,
      ExtensionElement = ExtensionElement,
      ExtensionAxis = ExtensionAxis,
      ExtensionMember = ExtensionMember,

      Period = Period,
      StartYear = StartYear,
      NoYears = NoYears,
      Year = Year,
      Ultimus = Ultimus,

      Small = Small
    ))

  if(as_data_frame) {
    # API returns count == 0 if there is no data
    if(!is.null(ret$count) && ret$count == 0) return(data.frame())

    # convert to data frame
    ret <- xbrlus_to_data_frame(ret)

    # convert dates and numbers
    numeric_cols <- intersect(c("amount", "decimals", "fact"), names(ret))
    date_cols <- intersect(c("periodStart", "periodEnd", "periodInstant"), names(ret))
    for(x in numeric_cols) {
      ret[[x]] <- as.numeric(ret[[x]])
    }
    for(x in date_cols) {
      ret[[x]] <- as.Date(ret[[x]])
    }
  }

  ret
}

#xbrlExtenstionElement function in R
xbrlExtensionElement <- function(
  Element,
  AccessionID = NULL,
  Accession = NULL,
  Namespace = NULL,
  as_data_frame = TRUE)
{

  ret <-
    xbrlus_get("xbrlExtensionElement", list(
      Element = Element,
      AccessionID = AccessionID,
      Accession = Accession,
      Namespace = Namespace
    ))
  if(as_data_frame) {
    ret <- xbrlus_to_data_frame(ret, "baseElement")
  }
  ret
}

#xbrlChildren function in R
xbrlTaxChildren <- function(Element,
                         Taxonomy,
                         GroupURI,
                         Linkbase = NULL,
                         ResetCache = FALSE,
                         as_data_frame = TRUE) {
  ret <-
    xbrlus_get("xbrlTaxChildren", list(
      Element = Element,
      Taxonomy = Taxonomy,
      GroupURI = GroupURI,
      Linkbase = Linkbase,
      ResetCache = ResetCache
    ))

  if(as_data_frame) {
    ret <- xbrlus_to_data_frame(ret)
  }
  ret
}


#xbrlChildren function in R
xbrlChildren <- function(Element, AccessionID = NULL, GroupURI,
                         Linkbase = NULL,
                         Accession = NULL,
                         NetworkLink = NULL,
                         as_data_frame = TRUE) {
  ret <-
    xbrlus_get("xbrlChildren", list(
      Element = Element,
      AccessionID = AccessionID,
      GroupURI = GroupURI,
      Linkbase = Linkbase,
      Accession = Accession,
      NetworkLink = NetworkLink
    ))

  if(as_data_frame) {
    ret <- xbrlus_to_data_frame(ret)
  }
  ret
}

#xbrlCIKLookup function in R
xbrlCIKLookup <- function(Ticker, as_data_frame = TRUE) {
  if(length(Ticker) > 1) {
    return(do.call(
      rbind,
      lapply(Ticker, xbrlCIKLookup, as_data_frame = as_data_frame)
    ))
  }

  ret <-
    xbrlus_get("xbrlCIKLookup", list(Ticker=Ticker), add_api_key = FALSE)[[1]]

  if(as_data_frame) {
    ret <- as.data.frame(ret, stringsAsFactors = FALSE)
  }
  ret
}


#' Print a statements object
#' @param x a statements object
#' @param ... further arguments passed to or from other methods.
#' @seealso xbrl_get_statements
#' @keywords internal
#' @export
print.statements <- function(x, ...) {
  cat("Financial statements repository\n")
  p1 <- 
    do.call(
      rbind,
      lapply(x, function(x) {
        data.frame(
          From = min(x$endDate),
          To = max(x$endDate),
          Rows = nrow(x), Columns = ncol(x)) 
      }))
  
  print(p1, ...)
}


#' Print a statement object
#' 
#' @param x a statement object
#' @param descriptions if TRUE labels are printed instead of element IDs
#' @param html print in html format (requires htmlTable)
#' @param big.mark big mark to format numbers
#' @param dateFormat format string for format dates
#' @param ... further arguments passed to or from other methods.
#' @export
print.statement <- function (x, descriptions = FALSE, html = FALSE, big.mark = "", dateFormat = NULL, ...) {

  # prints statement data in transposed form
  
  if(!"statement" %in% class(x))
    stop("Not a statement object")
  if( !all(c("endDate", "startDate", "contextId") %in% names(x)) )
    return(NextMethod(object = x, ...))
  if( nrow(x)<1 )
    return(NextMethod(object = x, ...))
  
  if( any(names(x)[1:finstr_ncol()] !=  finstr_cols()))
    return(NextMethod(object = x, ...))
  
  if(html) {
    return(print_htmlTable(x, big.mark = big.mark, dateFormat = dateFormat, ...))
  }
  
  cat( "Financial statement: ")
  cat( nrow(x), "observations from", min(x$endDate),"to",max(x$endDate), "\n")

  xt <- reshape_table(x)
  
  # description
  if(descriptions) {
    s_names <- xt[["labelString"]]  
  } else {
    s_names <- xt[["elementId"]]
  }
  s_names <- ifelse(nchar(s_names) > 58, paste0(substr(s_names, 1, 40), "..."), s_names)
  fill_blanks <- paste0(rep("  ", 20), collapse = "")
  s_names <- paste0(
    substring(fill_blanks, 1, xt$level*2-2), 
    ifelse(xt$level == 1, "  ", ifelse(xt$is_negative, "- ", "+ ")), 
    s_names,
    ifelse(c(xt$level[-1], 0) > xt$level, " = ", "")
    )
  s_names <- substring(s_names, 3)
    
  df1 <- cbind( Element = s_names, xt[,7:ncol(xt), drop = FALSE] )
  df1 <- df1[, c(1, ncol(df1):2)]
  print.data.frame(df1, right = FALSE, row.names = FALSE, ...)
  
}


#' Print check object
#' @param x check object
#' @param ... further arguments passed to or from other methods.
#' @keywords internal
#' @export
print.check <- function(x, ...) {
  errors <- x[x$error != 0, ]
  num_errors <- nrow(errors)
  num_el_errors <- length(unique(errors[,"elementId"]))
  cat("Number of errors: ", num_errors, "\n")
  cat("Number of elements in errors: ", num_el_errors, "\n")
  if(num_errors > 0) {
    lapply( split(errors, errors$elementId), function(el) {
      cat("\nElement:", el$elementId[1], " = ", el$expression[1], "\n" )
      print.data.frame(el[,c("date", "original", "calculated", "error")])
    })
  }
}

print_htmlTable <- function(x, big.mark = "", dateFormat = "%h %Y", ...) {
  if( !requireNamespace("htmlTable", quietly = TRUE)) {
    stop("htmlTable needed for this function to work. Please install it.",
         call. = FALSE)
  }
  x <- reshape_table(x)
  tab <- x[,-c(1, 2, 3, 4, 5, 6 )]
  labelString <- x$labelString
  #labelString <- ifelse(nchar(labelString) > 68, paste0(substr(labelString, 1, 65), "..."), labelString)
  labelString <- 
    paste0(substring(paste0(rep("&nbsp;", 20), collapse = ""), 1, x$level*18 - 18), 
           labelString)
  
  tab[,1:ncol(tab)] <- format(tab, big.mark = big.mark)
  
  
  to_strong <- function(x, b = TRUE) {
    ifelse(b, paste0("<strong>", x, "</strong>"), x )
  }
  
  row.names(tab) <- to_strong(labelString, !x$terminal)
  for(col in colnames(tab)) {
    tab[[col]] <- to_strong(tab[[col]], !x$terminal) 
  }
  if(!is.null(dateFormat))
    names(tab) <- format( as.POSIXct(names(tab)), dateFormat)
  tab <- tab[,ncol(tab):1]
  htmlTable::htmlTable(tab, align = paste(rep("r", ncol(tab) ), collapse = ""))
}



`%ggplot_replace%` <- function(e1, e2) 
{
  e1[names(e2)] <- e2
  e1
}

#' Plot double stacked bar 
#' 
#' @param x a statement object with
#' @param by_date if FALSE facets will be grouped by first element level
#' @param is_diff if TRUE data is rearanged to support negative values
#' @param dif_labels vector with two new labels in case of diff mode 
#' @param ... other attributes
#' @export
plot_double_stacked_bar <- function(
  x, by_date = TRUE, is_diff = FALSE, dif_labels = NULL, ... ) {
      
  if( !requireNamespace("ggplot2", quietly = TRUE)) {
    stop("ggplot2 needed for this function to work. Please install it.",
         call. = FALSE)
  }
  
  # x <- bs1
  gg_data <- 
    x %>%
    reshape_long(levels = 2) %>%
    dplyr::arrange_(~parent_id, ~desc(element_id))
  
  gg_data$label <- factor(gg_data$label, levels = unique(gg_data$label))
  gg_data$parent_label <- factor(gg_data$parent_label, levels = unique(gg_data$parent_label))
  

  
  if(is_diff) {
    
    if(missing(dif_labels)) {
      dif_labels <- c("Consumption", "Supply")
    }
    
    gg_data <- gg_data %>%
      dplyr::mutate_(
        side = ~ ifelse(side == names(x)[[1]],
                        ifelse(Value >=0, dif_labels[1], dif_labels[2]),
                        ifelse(Value >=0, dif_labels[2], dif_labels[1])
        ),
        Value = ~ abs(Value)
      )
  }
  # wrap labels
  levels(gg_data$label) <-
    sapply(strwrap(levels(gg_data$label), width=15, simplify=FALSE), 
           paste, collapse="\n")
  levels(gg_data$parent_label) <-
    sapply(strwrap(levels(gg_data$parent_label), width=15, simplify=FALSE), 
           paste, collapse="\n")
  
  # decimals
  gg_data$value <- gg_data$value * 10 ^ gg_data$decimals
  
  # colors
  data_dims <- colSums(table(unique(gg_data[,c("element", "parent")])))
  
  bs_colors <- c(
    grDevices::hcl(h = 240, c = 30, l = seq(30, 80, len = data_dims[1])),
    grDevices::hcl(h = 120, c = 30, l = seq(30, 80, len = data_dims[2]))
  )

  g1 <-      
    ggplot2::ggplot(data = gg_data) +
    ggplot2::geom_bar(
      ggplot2::aes_string(
        y = "value", 
        x = ifelse(by_date, "parent_label","date"), 
        fill = "label"), 
      stat="identity", position='stack') +
    #geom_text(aes(label = pos, y = pos, x = side), size = 3) +
    ggplot2::scale_fill_manual(values = bs_colors) +
    ggplot2::guides(fill = ggplot2::guide_legend(title = NULL, reverse = TRUE)) +
    ggplot2::theme_minimal() %ggplot_replace%
    ggplot2::theme( 
      axis.title.x = ggplot2::element_blank(),
      axis.title.y = ggplot2::element_blank(),
      axis.ticks.y = ggplot2::element_blank(),
      axis.ticks.x = ggplot2::element_blank(),
      panel.grid.major.x = ggplot2::element_blank(),
      panel.grid.minor.x = ggplot2::element_blank(),
      panel.grid.minor.y = ggplot2::element_blank()
    )
  
  if(by_date) {
    g1 + ggplot2::facet_grid( ~ date )
  } else {
    g1 + ggplot2::facet_grid( ~ parent_label)
  }
      
}
    
#' Plot waterfall
#' 
#' @description Plots income statement as waterfall bar chart
#' @details Requires ggplot2. 
#' @param x a statement object (usually income statement)
#' @param date end date of selected period
#' @param ... other attributes
#' @export
plot_waterfall <- function(x, date = NULL, ...) {
  
  if( !requireNamespace("ggplot2", quietly = TRUE)) {
    stop("Package ggplot2 needed for this function to work. Please install it.",
         call. = FALSE)
  }
  if( !requireNamespace("scales", quietly = TRUE)) {
    stop("Package scales needed for this function to work. Please install it.",
         call. = FALSE)
  }

  row_num <- 1
  if(!missing(date)) {
    row_num <- which(x$endDate == date) 
  } else {
    if( nrow(x) > 1 ) {
      row_num <- nrow(x)
    } 
  }
  x <- x[row_num, ]
  
  decimals <- x$decimals
  
  elements <- 
    get_elements(x, all = FALSE)
  elements$sign <- 
    ifelse(elements$balance == "credit", 1, -1)
  elements$value <- 
    unlist( x[1, elements$elementId]) * elements$sign * 10 ^ x$decimals
  elements$position <- 
    cumsum(c(0, elements$value[-nrow(elements)]))
  elements$time <- 1:nrow(elements)
  
  elements$labelString <-
    sapply(strwrap(elements$labelString, width=15, simplify=FALSE), 
           paste, collapse="\n")
  
  
  # Adapted from http://vita.had.co.nz/papers/ggplot2-wires.pdf (waterfall example):
  ggplot2::ggplot(elements) +
    ggplot2::geom_hline(yintercept = 0, colour = "grey", size = 0.5) +
    ggplot2::geom_rect(ggplot2::aes_string(xmin = "time - 0.45", xmax = "time + 0.45", 
                  ymin = "position", ymax = "position + value", fill = "factor(sign)")) +
    ggplot2::geom_text(ggplot2::aes_string(
      x = "time", 
      y = "pmin(position, position + value) - 50", label = "scales::comma(value)"),
      hjust = 0.5, vjust = 1, size = 3) +
    ggplot2::scale_x_continuous( breaks = elements$time, labels = elements$labelString) +
    ggplot2::scale_y_continuous(labels = scales::comma) +
    ggplot2::scale_fill_manual(values = c("-1" = "#9ecae1", "1" = "#3182bd"), guide = "none") +    
    ggplot2::theme_bw() %ggplot_replace% 
    ggplot2::theme( axis.title.x = ggplot2::element_blank(),
                    axis.title.y = ggplot2::element_blank(),
                    axis.ticks.x = ggplot2::element_blank(),
                    axis.ticks.y = ggplot2::element_blank(),
                    panel.grid.major.x = ggplot2::element_blank(),
                    panel.grid.minor.x = ggplot2::element_blank(),
                    panel.grid.minor.y = ggplot2::element_blank(),
                    panel.border = ggplot2::element_blank()
    )
}




#' @name xbrl_data_aapl2014
#' @title XBRL data from SEC archive
#' @description parsed XBRL files from 
#'    http://edgar.sec.gov/Archives/edgar/data/320193/000119312514383437/aapl-20140927.xml
#'    using XBRL::xbrlDoAll
#'    and truncating to only necessary data
#' @usage data(xbrl_data_aapl2014) 
#' @docType data
NULL

#' @name xbrl_data_aapl2013
#' @title XBRL data from SEC archive
#' @description parsed XBRL files from 
#'    http://edgar.sec.gov/Archives/edgar/data/320193/000119312513416534/aapl-20130928.xml
#'    using XBRL::xbrlDoAll
#'    and truncating to only necessary data
#' @usage data(xbrl_data_aapl2013) 
#' @docType data
NULL

#' Function to create package data included in the package
#' 
#' @details xbrlDoAll creates > 5Mb list - we need only 2Mb
#' @keywords internal
xbrl_create_data <-function() {

  file1 <- "http://edgar.sec.gov/Archives/edgar/data/320193/000119312513416534/aapl-20130928.xml"
  file2 <- "http://edgar.sec.gov/Archives/edgar/data/320193/000119312514383437/aapl-20140927.xml" 

  xbrl_data_aapl2013 <- XBRL::xbrlDoAll(file1)
  xbrl_data_aapl2014 <- XBRL::xbrlDoAll(file2)
  
  
  xbrl_data_aapl2013$unit <- NULL
  xbrl_data_aapl2013$footnote <- NULL
  xbrl_data_aapl2013$definition <- NULL
  xbrl_data_aapl2013$presentation <- NULL
  xbrl_data_aapl2013$element <- 
    xbrl_data_aapl2013$element %>%
    dplyr::semi_join(xbrl_data_aapl2013$fact, by="elementId" )
  
  xbrl_data_aapl2014$unit <- NULL
  xbrl_data_aapl2014$footnote <- NULL
  xbrl_data_aapl2014$definition <- NULL
  xbrl_data_aapl2014$presentation <- NULL
  xbrl_data_aapl2014$element <- 
    xbrl_data_aapl2014$element %>%
    dplyr::semi_join(xbrl_data_aapl2014$fact, by="elementId" )
  
  # devtools::use_data(xbrl_data_aapl2013, overwrite = T)
  # devtools::use_data(xbrl_data_aapl2014, overwrite = T)
  
}


finstr_cols <- function(x = NULL, inverse = FALSE) {
  cols <- c("contextId", "startDate", "endDate", "decimals")
  if(!missing(x)) {
    if(inverse){
      cols <- names(x)[!names(x) %in% cols]
    } else {
      cols <- names(x)[names(x) %in% cols]
    }
  }
  return(cols)
}

finstr_ncol <- function() length (finstr_cols())
finstr_values <- function(x) (x[(finstr_ncol()+1):ncol(x)])

  
#' Get a vector of statement IDs
#' @param xbrl_vars XBRL data
#' @importFrom magrittr "%>%"
#' @keywords internal
#' @export
xbrl_get_statement_ids <- function(xbrl_vars) {
  # finds roleIds for statements
  # example:
  #   xbrl_get_statements(xbrl_vars)
  
  if( !all( c("role", "calculation") %in% names(xbrl_vars)))
    stop(substitute(xbrl_vars), " does not include role and calculation data.")
  
  xbrl_vars$role %>%
    dplyr::filter_(~type == "Statement") %>%
    dplyr::semi_join(xbrl_vars$calculation, by = "roleId") %>%
    dplyr::select_(~roleId) %>%
    simplify2array() %>%
    unname()
}

#' Get a statement from data (data for specified elements)
#' @param elements elements object
#' @param xbrl_vars XBRL data
#' @param complete_only just the rows without NA
#' @param complete_first just the rows without NA in first column
#' @param basic_contexts in case of duplicated periods, get only basic contexts
#' @keywords internal
#' @export
xbrl_get_data <- function(elements, xbrl_vars, 
                          complete_only = FALSE, complete_first = TRUE, 
                          basic_contexts = TRUE) {
  # gets data in normal format (with variables as columns and 
  # time periods as rows)
  
  if( !("data.frame" %in% class(elements)) )
    elements <- data.frame(elementId = elements, stringsAsFactors = FALSE)
  
  res <-
    elements %>%
    dplyr::inner_join(xbrl_vars$fact, by = "elementId")

  min_level <- min(res$level, na.rm = TRUE)

  min_dec <- min(as.numeric(res$decimals), na.rm = TRUE)
  
  context_filter <- res %>% dplyr::filter_(~level == min_level) %>%
    getElement("contextId") %>% unique

  decimals_filter <- res %>% dplyr::filter_(~level == min_level) %>%
    getElement("decimals") %>%  unique
  
  res <-
    res %>%
    dplyr::filter_(~contextId %in% context_filter) %>% 
    dplyr::filter_(~decimals %in% decimals_filter) %>% 
    dplyr::mutate_(fact = ~as.numeric(fact), decimals = ~min_dec )%>%
    dplyr::inner_join(xbrl_vars$context, by = "contextId") %>%
    dplyr::select_(~contextId ,  ~startDate ,  ~endDate ,  ~elementId ,  ~fact ,  ~decimals) %>%
    #dplyr::add_rownames() %>% 
    tidyr::spread_("elementId", "fact") %>%
    dplyr::arrange_(~endDate)
  

  vec1 <- elements$elementId[! elements$elementId %in% names(res)]
  df1 <- stats::setNames( data.frame(rbind(rep(0, length(vec1)))), vec1)
  res <- cbind(res, df1)
  
  value_cols <- finstr_cols(res, inverse = TRUE)
  
  #res <- res[, c(names(res)[1:4], elements$elementId)]
  res <- res[, c(finstr_cols(res), elements$elementId)]

  # Handling strange NAs - if some columns are total NA:
  empty_cols <- sapply(
    res[elements$elementId], function(x) length(stats::na.omit(x))==0 
  )
  res[, names(empty_cols)[ empty_cols]] <- 0
  
  # keep only complete rows
  if(complete_only)
    res <- res[stats::complete.cases( res[ value_cols ] ), ]
  # only basic_contexts
  if(basic_contexts) {
    context_filter2 <-
      res %>% 
      dplyr::group_by_(~startDate, ~endDate) %>% 
      dplyr::summarise_(min_context = ~contextId[nchar(contextId) == min(nchar(contextId))]) %>% 
      getElement("min_context")
    
    res <- res %>% dplyr::filter_(~contextId %in% context_filter2)
  }
  
  if(complete_first)
    res <- res[!is.na(res[, value_cols[1]]), ]
  
  if(any(duplicated(res$endDate))) {
    #warning("Rows with duplicated endDate")
    rownames(res) <- res$contextId
  } else {
    rownames(res) <- res$endDate
  }
  
  class(res) <- c("statement", "data.frame")
  return(res)
}



xbrl_get_elements <- function(xbrl_vars, relations) {
  if(nrow(relations) == 0) {
    return(NULL)
  }
  # get elements & parent relations & labels
  elements <-
    data.frame( 
      elementId = with(relations, unique(c(fromElementId, toElementId))),
      stringsAsFactors = FALSE
      )  %>%
    dplyr::left_join(xbrl_vars$element, by = c("elementId")) %>%
    #dplyr::filter_(~type == "xbrli:monetaryItemType") %>% 
    dplyr::left_join(relations, by = c("elementId" = "toElementId")) %>%
    dplyr::left_join(xbrl_vars$label, by = c("elementId")) %>%
    dplyr::filter_(~labelRole == "http://www.xbrl.org/2003/role/label") %>% 
    dplyr::transmute_(~elementId, parentId = ~fromElementId, ~order, ~balance, ~labelString)
  
  elements <- get_elements_h(elements)
  
  class(elements) <- c("elements", "data.frame")
  return(elements)
}


#' Get elements hierarchy 
#' 
#' @details Add level and hierarchycal id columns
#' @param elements data.frame with elementId, parentId and order columns 
#' @export
#' @keywords internal
get_elements_h <- function(elements) {
  # reorder and classify elements by hierarchy
  # adds level, hierarchical id and terminal column  
  level <- 1
  df1 <- elements %>%
    dplyr::filter_(~is.na(parentId)) %>%
    dplyr::mutate(id = "") %>% 
    dplyr::arrange_(~dplyr::desc(balance))

  while({
    level_str <- 
      unname(unlist(lapply(split(df1$id, df1$id), function(x) {
        sprintf("%s%02d", x, 1:length(x))
      })))
    
    elements[elements$elementId %in% df1$elementId, "level"] <- level
    to_update <- elements[elements$elementId %in% df1$elementId, "elementId"]
    elements[ 
      #order(match(elements$elementId, to_update))[1:length(level_str)], 
      order(match(elements$elementId, df1$elementId))[1:length(level_str)], 
      "id"] <- level_str
    
    df1 <- elements %>%
      dplyr::filter_(~parentId %in% df1$elementId) %>%
      dplyr::arrange_(~order) %>%
      dplyr::select_(~elementId, ~parentId) %>%
      dplyr::left_join(elements, by=c("parentId"="elementId")) %>%
      dplyr::arrange_(~id)
    nrow(df1) > 0})
  {
    level <- level + 1
  }

  elements <- 
    elements %>%  
    dplyr::arrange_(~id) %>% 
    dplyr::mutate_( terminal = ~ !elementId %in% parentId )
}

#' Get relations from XBRL calculation link base
#' @param xbrl_vars XBRL data (list of dataframes)
#' @param role_id id of role (usually of type statement)
#' @param lbase link base (default is calculation)
#' @keywords internal
#' @export
xbrl_get_relations <- function(xbrl_vars, role_id, lbase = "calculation") {
  
  res <- 
    xbrl_vars[[lbase]] %>%
    dplyr::filter_(~roleId == role_id) %>%
    dplyr::select_(~fromElementId, ~toElementId, ~order) %>% 
    dplyr::mutate(order = as.numeric(order)) %>%
    dplyr::arrange(order) %>% 
    unique() 

  # check the hierarchy: children should not be duplicated
  duplicated_children <- duplicated(res$toElementId)
  if(any(duplicated_children)) {
    res <- res[!duplicated_children, ]
    warning("Found and removed duplicated children in ", lbase, "/",role_id, call. = FALSE)
  }
  class(res) <- c("xbrl_relations", "data.frame")
  return(res)
}

#' Get a financial statements object from XBRL
#' 
#' @param xbrl_vars a XBRL parsed object
#' @param rm_prefix a prefix to remove from element names
#' @param complete_only Get only context with complete facts
#' @param complete_first Get only context with non-NA first fact
#' @param role_ids specify statements (all statements are returned by default)
#' @param lbase link base ("calculation" is default)
#' @param basic_contexts when duplicated periods, only basic contexts are returned
#' @return A statements object
#' @examples
#' \dontrun{
#' 
#' # parse XBRL to XBRL data and get statements:
#' xbrl_url <- "http://edgar.sec.gov/Archives/edgar/data/320193/000119312514383437/aapl-20140927.xml"
#' xbrl_data <- xbrl_parse_min(xbrl_url)
#' st1 <- xbrl_get_statements(xbrl_data)
#' 
#' # get statements directly from a url:
#' xbrl_url <- "http://edgar.sec.gov/Archives/edgar/data/320193/000119312514383437/aapl-20140927.xml"
#' st1 <- xbrl_get_statements(xbrl_url)
#' }
#' 
#' @seealso \link{finstr}
#' @export
xbrl_get_statements <- function(xbrl_vars, rm_prefix = "us-gaap_", 
                                complete_only = FALSE,
                                complete_first = TRUE, 
                                role_ids = NULL,
                                lbase = "calculation",
                                basic_contexts = TRUE )  {

  # xbrl is parsed xbrl
  if( !all( c("role", "calculation", "fact", "context", "element") %in% names(xbrl_vars))) {
    stop("Input does not include all data needed from XBRL.")
  }
  
  # get all statement types from XBRL
  if(missing(role_ids)) {
    role_ids <- xbrl_get_statement_ids(xbrl_vars)
  }
  
  #get calculation link base relations
  relations <- lapply(role_ids, function(role_id){
    xbrl_get_relations(xbrl_vars = xbrl_vars, role_id = role_id, lbase = lbase)
  })
  with_content <- vapply(relations, function(x) nrow(x) > 0, logical(1))
  if(!any(with_content)) {
    return(NULL)
  }
  relations <- relations[with_content]
  role_ids <- role_ids[with_content]
    
  names(relations) <- basename(role_ids)
  elements_list <- lapply(relations, function(x){
    xbrl_get_elements(xbrl_vars, x)
  })
  names(elements_list) <- basename(role_ids)
  
  taxonomy_prefix <- sprintf("^%s", rm_prefix)

  # store xbrl data in statement data structure
  statements <- 
    stats::setNames(
      lapply(
        role_ids,
        function(role_id) {
          stat_name <- basename(role_id)
          links <- relations[[stat_name]]
          elements <- elements_list[[stat_name]]
          #label <- xbrl_get_labels(xbrl_vars, elements)
          res <- xbrl_get_data(elements, xbrl_vars, 
                               complete_only, complete_first,
                               basic_contexts)
          # delete taxonomy prefix
          names(res) <- gsub(taxonomy_prefix, "", names(res))          
          links$fromElementId <- gsub(taxonomy_prefix, "", links$fromElementId)          
          links$toElementId <- gsub(taxonomy_prefix, "", links$toElementId)          
          elements$elementId <- gsub(taxonomy_prefix, "", elements$elementId)          
          elements$parentId <- gsub(taxonomy_prefix, "", elements$parentId)          
          # set attributes
          attr(res, "role_id") <- stat_name
          attr(res, "relations") <- links
          attr(res, "elements") <- elements
          res
        } 
      ),
      basename(role_ids)
    )
  class(statements) <- c("statements", "list")
  return(statements)
}




#' Get statement elements and the calculation hierarchy
#' 
#' @param x A statement object
#' @param parent_id used as filter if defined
#' @param all if FALSE only terminal elements from the hierarchy will be returned
#' @seealso \code{\link{calculate}}
#' @export
get_elements <- function(x, parent_id = NULL, all = TRUE) {
  # returns all terminating elements 
  # if parent_id provided, only descendands from this elements are returned

  if( is.null(x)  ) {
    stop("No statement")
  }
  if( !"statement" %in% class(x)  ) {
    stop("Not a statement class")
  }

  elements <- attr(x, "elements")
  
  if(!missing(parent_id)) {
    children <- elements[["elementId"]] == parent_id
    if(!any(children)) {
      stop("No children with parent ", parent_id, " found", call. = FALSE)
    }
    id_parent <- elements[["id"]][children]
    elements <- elements %>%
      dplyr::filter_(~substring(id, 1, nchar(id_parent)) == id_parent) %>%
      as.elements()

  }
  if(!all) {
    elements <- elements %>%
      dplyr::filter_(~terminal) %>%
      dplyr::mutate(level = 1) %>%
      as.elements()
  }

  return(elements)

}


#' Get descendands
#' @description Gets all descendand terminal elements from calculation tree
#' @param x a statement object
#' @param element_id element (or vector of elements) from statement hierarchy
#' @export
#' @keywords internal
get_descendants <- function(x, element_id, all = FALSE) {
  
  unique(do.call(c, lapply(
    element_id, function(e) {
      get_elements(x, parent_id = e, all)[["elementId"]]
    }
  )))
  
}

#' Get parent
#' @description Gets a parent element id
#' @param x a statement object
#' @param element_id element id
#' @export
#' @keywords internal
get_parent <- function(x, element_id) {
  elements <- get_elements(x)
  elements[elements$elementId %in% element_id,"parentId"]
}


#' Get ascendant
#' @description Gets common ascendant from elements
#' @param x a statement object
#' @param element_id elements
#' @export
#' @keywords internal
get_ascendant <- function(x, element_id) {
  elements <- get_elements(x)

  if( !all(element_id %in% elements[,"elementId"] )) 
    return(NULL)
  
  sel_elements <- elements[elements$elementId %in% element_id,]
  asc1 <- sapply(elements$id, function(x) { all(x == substring(sel_elements$id, 1, nchar(x)))})
  return(elements[asc1,"elementId"])
}


as.elements <- function(x) {
  if( !all(c("elementId", "parentId") %in% names(x))) {
    stop("Can't convert to elements")
  }
  class(x) <- c("elements", "data.frame")
  return(x)
}

#' Check statement
#' @description Checks statement calculation consistency
#' @param statement statement object
#' @param element_id element from hierarchy where to perform calculation (if specified)
#' @return check object with calculated and original values
#' @export
check_statement <- function(statement, element_id = NULL) {
  
  if(! "statement" %in% class(statement)) {
    stop("Not a statement object")
  }

  els <- get_elements(statement)
  if(is.null(els)) {
    stop("No calculation hierarchy found")
  }
  if(missing(element_id)) {
    element_id <- els$elementId
  }
  err1 <- do.call(
    rbind,
    lapply(element_id, function(x) {
      
      xb <- els$balance[els$elementId == x]
      xc <- stats::na.omit(els$elementId[els$parentId == x])
      xcb <- els$balance[els$element %in% xc]
      xcs <- ifelse( xb == xcb, 1, -1)
      xcv <- rowSums(  crossprod (t(statement[, xc]),  xcs) )
      xv <- statement[ , x]
      if(length(xc) == 0) {
        return(NULL)
      }
      err <- data.frame(
        date = statement$endDate, 
        elementId = x, 
        expression = paste(ifelse(xcs == 1, "+", "-"), xc, collapse = " "),
        original = xv,
        calculated = xcv,
        error = xv - xcv, 
        stringsAsFactors = FALSE)
      row.names(err) <- 1:nrow(err)
      return(err)
    })
  )
  class(err1) <- c("check", "data.frame")
  return(err1)
}



#' Merge statement elements object
#' 
#' @param x elements object
#' @param y elements object
#' @param ... ignored
#' @keywords internal
#' @export
merge.elements <- function(x, y, ...) {
  z <- NULL
  col_names <- names(x)[!names(x) %in% c("level", "id", "terminal")]
  z <- rbind(x[,col_names], y[,col_names])
  z <- z[!duplicated(z[,c("elementId", "parentId")]), ]  
  z <- get_elements_h(z)
  z <- as.elements(z)
  return(z)
}

#' Merge two financial statements
#' 
#' @description Merge two statements from different time periods.
#' @details
#' Since statements are basically data.frames the functions are similar. Except:
#' \itemize{
#' \item new statement elements are allways union of input elements,
#'   if taxonomy changes new and old elements are visible in all periods 
#' \item missing values are set to 0 not to NA as merge would normally do 
#' \item hierarchy is merged from both statements hierarchies
#' \item rows are treated as duplicated based on endDate and the row of x is 
#' allways considered as duplicate (so y should allways be the later statement)
#' }
#' 
#' @param x statement object
#' @param y statement object
#' @param replace_na (boolean) replace NAs with zeros  
#' @param ... further arguments passed to or from other methods
#' @return statement object
#' @export
merge.statement <- function(x, y, replace_na = TRUE, ...) {

  if( !"statement" %in% class(x) || !"statement" %in% class(y) ) {
    stop("Not statement objects")
  }
  
  # merge elements
  el_x <- get_elements(x)
  el_y <- get_elements(y)
  el_z <- merge(el_x, el_y)
  
  if(!any(names(x)[-(1:4)] %in% names(y)[-(1:4)])  ) {
    #if same period and different statments
    col_pos <- which(names(y) %in% c("contextId", "startDate", "decimals"))
    z <- 
      x %>%
      dplyr::left_join(y[,-col_pos], by = "endDate")
    
  } else {
    # if same statement type and different periods
    
    z <- merge.data.frame(x, y, all = TRUE, ...)
    # replace NAs in values by zeros
    if(replace_na) {
      z[,5:ncol(z)][is.na(z[,5:ncol(z)])] <- 0
    }
    # remove duplicated rows (based on periods)
    z <- z[!duplicated(z[c("endDate")], fromLast = TRUE), ]
    # order rows by endDate
    z <- z[order(z$endDate), ]
    # order columns based on original taxonomy
    z <- z[,c(names(z)[1:4], el_z[["elementId"]])]
  }
  
  # add attributes
  class(z) <- class(x)
  attr(z, "elements") <- el_z
  attr(z, "role_id") <- attr(x, "role_id")
  return(z)  
}



#' Merge two lists of statements
#' 
#' @details Merges all statements in x with all statements in y
#' @param x statements object
#' @param y statements object
#' @param replace_na (boolean) replace NAs with zeros  
#' @param ... further arguments passed to or from other methods
#' @return statements object
#' @seealso \link{merge.statement} for merging two statements
#' @export
merge.statements <- function(x, y, replace_na = TRUE, ...) {

  if( !"statements" %in% class(x) || !"statements" %in% class(y) ) {
    stop("Not statements objects")
  }
  
  z <-
    lapply(names(x), function(statement){
      merge(x[[statement]], y[[statement]], replace_na = replace_na, ...)
    })
  names(z) <- names(y)
  class(z) <- "statements"
  return(z)
}


#' Calculate formulas 
#' 
#' @param x a statement object
#' @param ... list of formulas
#' @param calculations optional: calculations generated by calculation function
#' @param digits if specified the result will be rounded according to number of digits
#' @param decimals if specified the result will be multiplied by 10^decimals
#' @return data frame with date and specified columns
#' @examples
#' \dontrun{
#' 
#' balance_sheet %>% calculate(
#'   
#'   current_ratio = AssetsCurrent / LiabilitiesCurrent,
#'   
#'   quick_ratio =  
#'     ( CashAndCashEquivalentsAtCarryingValue + 
#'         AvailableForSaleSecuritiesCurrent +
#'         AccountsReceivableNetCurrent
#'       ) / LiabilitiesCurrent
#' )
#' }
#' @seealso \code{\link{calculation}}
#' @export
calculate <- function(x, ..., digits = NULL, decimals = NULL, calculations = NULL) {
  # calculate
  res <- dplyr::transmute_(x, date = ~endDate, .dots = c(lazyeval::lazy_dots(... ),calculations))
  # remove hidden columns (leading dots)
  res <- res[grep("^[^\\.]", names(res))]
  # rounding results
  if(!missing(digits)) {
    res[,2:ncol(res)] <- round(res[,2:ncol(res)], digits) 
  }
  if(missing(decimals)) {
    if(!is.null(x[["decimals"]])) {
      decimals <- min(x[["decimals"]], na.rm = TRUE)
    }
    if(!is.null(x[["decimals.x"]])) {
      decimals <- min(x[["decimals.x"]], na.rm = TRUE)
    }
  }
  if(!is.null(decimals) && !is.na(decimals) && 
       max(abs(res[1:5,2:ncol(res)]), na.rm = TRUE)>10^(-decimals)) {
    res[,2:ncol(res)] <- res[,2:ncol(res)] * 10 ^ decimals 
  }
  return(res)
}

#' Define calculation
#' @param ... formulas
#' @seealso \code{\link{calculate}}
#' @examples
#' \dontrun{
#' 
#' profit_margins <- calculation(
#'  Gross_Margin = (SalesRevenueNet - CostOfGoodsAndServicesSold) / SalesRevenueNet,
#'  Operating_Margin = OperatingIncomeLoss / SalesRevenueNet,
#'  Net_Margin = NetIncomeLoss / SalesRevenueNet
#' )
#' 
#' income_statement %>% calculate(calculations = profit_margins)
#' }
#' @export
calculation <- function(...) {
  lazyeval::lazy_dots(...) 
}




#' Statement lagged differences
#' 
#' @param x a statement to be differenced
#' @param lag an integer indicating which lag to use
#' @param ... further arguments passed to or from other methods
#' @return a statement object equal to successive  differences (x and lagged x)
#' @export
diff.statement <- function(x, lag = 1L, ...) {
  y <- x[-((nrow(x)-lag+1):nrow(x)),]
  y$endDate <- x$endDate[-(1:lag)]
  y[,5:ncol(y)] <- x[-(1:lag),5:ncol(x)] - y[,5:ncol(y)]
  return(y)
}

#'Without operator
#'@param a element id from element hierarchy
#'@param b element id from element hierarchy
#'@description Used inside fold function to select elements in a without elements in b
#'@return Lazy object with function to select statement elements in a witout elements in b
#'@export
#'@keywords internal
`%without%` <- function (a, b) {
  # declare x and y just to let the check now there is no problem...
  # x will be a statement object when the expression evaluates
  # y will be all used elements
  x <- NULL
  y <- NULL

  lazyeval::lazy(
    setdiff( setdiff( get_descendants(x, a), get_descendants(x, b)), y)
  )
}

#' Proportional values
#' 
#' Every value in the financial statement is divided by topmost parent's value
#' @param x a statement object
#' @param digits if specified number of digits to round the result
#' @export
proportional <- function(x, digits = NULL) {
  y <- x
  for(col_name in get_elements(x)[["elementId"]]) {
    parent_id <- get_ascendant(x, col_name)[[1]]
    x[[col_name]] <- y[[col_name]] / y[[parent_id]]
    if(!missing(digits)) {
      x[[col_name]] <- round(x[[col_name]], digits )
    }
  }
  x[["decimals"]] <- 0
  return(x)
}

#'Other elements
#'@param ... element IDs from element hierarchy
#'@description Used inside expose function to select all other elements
#'@return Lazy object with function to select elements from statement x
#'@export
#'@keywords internal
other <- function (...) {
  # declare x and y just to let the check now there is no problem...
  # x will be a statement object when the expression evaluates
  # y will be all used elements
  x <- NULL
  y <- NULL
  
  lazyeval::lazy(
    setdiff(get_descendants(x, c(...) ), y)
  ) 
}



#' Reshape to "long" format
#' @description Reshapes statement object to a data frame with one value column
#'  and dimension columns (endDate, elementId and parentId). 
#' @param x a statement object
#' @param levels if defined only elements from specified levels will be included
#' @export
reshape_long <- function(x, levels = NULL) {
  elements <- get_elements(x)
  if(missing(levels)) levels <- unique(elements[["level"]])

  x %>%
    tidyr::gather_("elementId", "value", elements[["elementId"]], convert = FALSE) %>%
    dplyr::mutate_("elementId" = ~as.character(elementId)) %>%
    dplyr::inner_join(elements, by = "elementId") %>%
    dplyr::filter_(~!is.na(parentId) & level %in% levels ) %>%
    dplyr::select_(date = ~endDate, element = ~elementId, parent = ~parentId, ~value, 
            label = ~labelString, ~decimals, element_id = ~id) %>%
    dplyr::left_join(elements, by = c("parent" = "elementId")) %>%
    dplyr::select_(~date, ~element, ~parent, ~value, ~label, 
            parent_label = ~labelString, ~decimals, 
            ~element_id,  parent_id = ~id)

}

#' Reshape statement data to table format
#' 
#' Transposes data to "print-out" format
#' @param x a statement object
#' @param decimals return values with decimals
#' @export
#' @keywords internal
reshape_table <- function(x, decimals = TRUE, simple = FALSE) {

  e <- get_elements(x)
  values <- finstr_values(x) 

  if(decimals) {
    decimals_no <- min(x[["decimals"]])
    if(is.na(decimals_no)) decimals_no <- 0
    values <- values * 10 ^ decimals_no
  }
  
  parent_pos <- match(e[["parentId"]], e[["elementId"]])
  is_negative <- e[,"balance"] != e[parent_pos, "balance"]
  is_negative[is.na(is_negative)] <- FALSE
  
  ret <- cbind(e[,c("elementId", "level", "id", "terminal", "labelString")], is_negative, t(values))
  if(!any(duplicated(x$endDate))) {
    names(ret)[7:ncol(ret)] <- x$endDate
  } else {
    names(ret)[7:ncol(ret)] <- x$contextId
  }
  row.names(ret) <- 1:nrow(ret)
  if(simple) {
    ret <- ret[, -c(1, 2, 3, 4, 6)]
  }
  return(ret)
}


expose_prepare <- function(x, e_list) {
  used_elements <- c()
  ret_list <- list()
  
  for(exp_name in names(e_list) ) { 
    exp_els <- e_list[[exp_name]]
    
    # Elements can be defined as a function (lazy object)
    # ... or as descendands of specified elements
    if("lazy" %in% class(exp_els)) {
      els <- lazyeval::lazy_eval( exp_els, 
                                  data = list(x = x, y = used_elements))
    } else {
      els <- unname(get_descendants(x, exp_els))
    }
    if( any(els %in% used_elements) ) {
      warning("The duplicate elements will be removed from ", 
              exp_name, ": ",
              els[ els %in% used_elements],
              call. = FALSE)
      els <- setdiff( els, used_elements)
    }
    # track used elements
    used_elements <- c(used_elements, els)
    # result
    ret_list[[exp_name]] <- els    
  }
  
  # pick all leftovers
  elements <- get_elements(x, all = FALSE)[["elementId"]]
  the_rest <- setdiff(elements, used_elements)
  if(length(the_rest) > 0) {
    the_rest <- split(the_rest, sapply(the_rest, function(s) get_ascendant(x, s)[1]))
    for(tr in names(the_rest)) {
      ret_list[[paste0("Other",tr,"_")]] <- the_rest[[tr]]
    }
  }
  
  return(ret_list)
}


#' Expose financial sheet values
#' 
#' Simplifies statement to 2-level hierarchy.
#' Elements are defined by list of element vectors.
#' 
#' @param x a statement object
#' @param ... expressions to expose values
#' @param e_list expressions to expose values
#' @examples
#' 
#' \dontrun{
#' expose(balance_sheet,
#'                      
#'   # Assets
#'   `Current Assets` = "AssetsCurrent",
#'   `Noncurrent Assets` = other("Assets"),
#'   # Liabilites and equity
#'   `Current Liabilities` = "LiabilitiesCurrent",
#'   `Noncurrent Liabilities` = other(c("Liabilities", "CommitmentsAndContingencies")),
#'   `Stockholders Equity` = "StockholdersEquity"
#' )
#' }
#' @export
expose <- function(x, ..., e_list = NULL) {
  
  # concatenate dots and list arguments
  e_list <- c(e_list, list(...))
  # prepare list of elements
  if(length(e_list) > 0)
    e_list <- expose_prepare(x, e_list)
  
  descriptions <- names(e_list)
  names(e_list) <- make.names(names(e_list))
  
  # initial y = top level elements from x
  x_els <- get_elements(x)
  y_els <- x_els[ x_els$level == 1, ]
  y_els$terminal <- TRUE
  y <- x[, c(names(x)[1:4], y_els$elementId)]
  attr(y, "elements") <- y_els

  for(exp_name in names(e_list) ) { 
    els <- e_list[[exp_name]]
    description <- descriptions[which(exp_name == names(e_list))]
    # add a row in elements object
    parent_id <- get_ascendant(x, els)[1]
    if(is.na(parent_id) || length(parent_id) == 0)
      stop("A group of elements defined too broadly")
    balance <- x_els[ x_els$elementId == parent_id, "balance" ]
    labelString <- description
    
    y_els <-
      dplyr::bind_rows(y_els, dplyr::data_frame(
          elementId = exp_name,
          parentId = parent_id,
          order = 1,
          balance = balance,
          labelString = labelString))
    
    # calculate value
    xb <- x_els$balance[x_els$elementId == parent_id]
    xc <- stats::na.omit(x_els[x_els$elementId %in% els, "elementId"])
    xcb <- x_els[x_els$elementId %in% xc, "balance"]
    xcs <- ifelse(xb == xcb, 1, -1)
    xcv <- rowSums(crossprod(t(x[, xc]), xcs), na.rm = TRUE )
    y[[exp_name]] <- xcv
    
    # rearrange hierarchy
    y_els <- get_elements_h(y_els[1:5])
    y_els <- as.elements(y_els)
    y <- y[,c(names(x)[1:4], y_els$elementId)]
    attr(y, "elements") <- y_els
  }
  
  return(y)
}


#New Path
install.packages("xml")

install.packages('xml',repos='http://cran.us.r-project.org')


Sys.unsetenv("GITHUB_PAT")
remotes::install_github(
  repo = "bergant/finstr", force = TRUE)  

library(XBRL)
# parse XBRL (Apple 10-K report)
xbrl_url2014 <- "https://www.sec.gov/Archives/edgar/data/320193/000119312514383437/aapl-20140927.xml"

xbrl_url2013 <- 
  "https://www.sec.gov/Archives/edgar/data/320193/000119312513416534/aapl-20130928.xml"

xbrl_url_google_2019 <- "https://www.sec.gov/Archives/edgar/data/1652044/000165204420000008/goog10-k2019_htm.xml"

xbrl_url_google_2017 <- "https://www.sec.gov/Archives/edgar/data/1652044/000165204417000026/goog-20170630.xml"


xbrl_url_google_2018Q4 <- "https://www.sec.gov/Archives/edgar/data/1652044/000165204419000004/goog-20181231.xml"

old_o <- options(stringsAsFactors = FALSE)

xbrl_data_aapl2014 <- xbrlDoAll(xbrl_url2014)
xbrl_data_aapl2013 <- xbrlDoAll(xbrl_url2013)

xbrl_data_goog2018Q4 <- xbrlDoAll(xbrl_url_google_2018Q4)

options(old_o)

library(finstr)

st2013 <- xbrl_get_statements(xbrl_data_aapl2013)
st2014 <- xbrl_get_statements(xbrl_data_aapl2014)
st2019 <-  xbrl_get_statements(xbrl_data_goog2019)

balance_sheet2013 <- st2013$StatementOfFinancialPositionClassified
balance_sheet2014 <- st2014$StatementOfFinancialPositionClassified
balance_sheet2019 <- st2019$ConsolidatedBalanceSheets

income2013 <- st2013$StatementOfIncome
income2014 <- st2014$StatementOfIncome
income2019 <- st2019$ConsolidatedStatementsOfIncome

balance_sheet2019


```




```{r}
inst <- "http://www.sec.gov/Archives/edgar/data/1223389/000122338914000023/conn-20141031.xml"
options(stringsAsFactors = FALSE)
xbrl.vars <- xbrlDoAll(inst)
xbrl.sec <- xbrlSECdev01(xbrl.vars)
xbrl.sec$showStatements()

inst <- "http://www.sec.gov/Archives/edgar/data/1223389/000122338914000023/conn-20141031.xml"
options(stringsAsFactors = FALSE)
xbrl.vars <- xbrlDoAll(inst)

# the final data frame structure is
Sys.unsetenv("GITHUB_PAT") 

remotes::install_github(
  repo = "bergant/xbrlus")

library(xbrlus)

companies <- xbrlCIKLookup(c("aapl","goog","fb"))

elements <- xbrlBaseElement(c("AssetsCurrent","AssetsNoncurrent","Assets","LiabilitiesCurrent",
  "LiabilitiesNoncurrent","Liabilities","StockholdersEquity","MinorityInterest",
  "StockholdersEquityIncludingPortionAttributableToNoncontrollingInterest","LiabilitiesAndStockholdersEquity"))

normalizePath("~")





  ```